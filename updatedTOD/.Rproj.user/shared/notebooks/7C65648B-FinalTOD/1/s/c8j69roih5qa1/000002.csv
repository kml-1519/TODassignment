"0","knitr::opts_chunk$set("
"0","    message = FALSE,"
"0","    warning = FALSE,"
"0","    include = FALSE "
"0",")"
"0","options(scipen=999)"
"0","options(tigris_class = ""sf"")"
"0",""
"0",""
"0","library(tidyverse)"
"2","Registered S3 methods overwritten by 'dbplyr':
  method         from
  print.tbl_lazy     
  print.tbl_sql      
"
"2","[30m-- [1mAttaching packages[22m ------------------------------------------------- tidyverse 1.3.1 --[39m
"
"2","[30m[32mv[30m [34mggplot2[30m 3.3.5     [32mv[30m [34mpurrr  [30m 0.3.4
[32mv[30m [34mtibble [30m 3.1.4     [32mv[30m [34mdplyr  [30m 1.0.7
[32mv[30m [34mtidyr  [30m 1.1.3     [32mv[30m [34mstringr[30m 1.4.0
[32mv[30m [34mreadr  [30m 2.0.1     [32mv[30m [34mforcats[30m 0.5.1[39m
"
"2","[30m-- [1mConflicts[22m ---------------------------------------------------- tidyverse_conflicts() --
[31mx[30m [34mdplyr[30m::[32mfilter()[30m masks [34mstats[30m::filter()
[31mx[30m [34mdplyr[30m::[32mlag()[30m    masks [34mstats[30m::lag()[39m
"
"0","library(tidycensus)"
"0","library(sf)"
"2","Linking to GEOS 3.9.0, GDAL 3.2.1, PROJ 7.2.1
"
"0","library(kableExtra)"
"2","
Attaching package: â€˜kableExtraâ€™

"
"2","The following object is masked from â€˜package:dplyrâ€™:

    group_rows

"
"0","library(tmap)"
"2","Registered S3 method overwritten by 'htmlwidgets':
  method           from         
  print.htmlwidget tools:rstudio
"
"0","census_api_key(""1d63e5e6e661f6fd556f9671502bf3879e3a9fd3"", overwrite = TRUE)"
"2","To install your API key for use in future sessions, run this function with `install = TRUE`.
"
"0","#multiring buffer function"
"0","  multipleRingBuffer <- function(inputPolygon, maxDistance, interval) "
"0","  {"
"0","    #create a list of distances that we'll iterate through to create each ring"
"0","    distances <- seq(0, maxDistance, interval)"
"0","    #we'll start with the second value in that list - the first is '0'"
"0","    distancesCounter <- 2"
"0","    #total number of rings we're going to create"
"0","    numberOfRings <- floor(maxDistance / interval)"
"0","    #a counter of number of rings"
"0","    numberOfRingsCounter <- 1"
"0","    #initialize an otuput data frame (that is not an sf)"
"0","    allRings <- data.frame()"
"0","    "
"0","    #while number of rings  counteris less than the specified nubmer of rings"
"0","    while (numberOfRingsCounter <= numberOfRings) "
"0","    {"
"0","      #if we're interested in a negative buffer and this is the first buffer"
"0","      #(ie. not distance = '0' in the distances list)"
"0","      if(distances[distancesCounter] < 0 & distancesCounter == 2)"
"0","      {"
"0","        #buffer the input by the first distance"
"0","        buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])"
"0","        #different that buffer from the input polygon to get the first ring"
"0","        buffer1_ <- st_difference(inputPolygon, buffer1)"
"0","        #cast this sf as a polygon geometry type"
"0","        thisRing <- st_cast(buffer1_, ""POLYGON"")"
"0","        #take the last column which is 'geometry'"
"0","        thisRing <- as.data.frame(thisRing[,ncol(thisRing)])"
"0","        #add a new field, 'distance' so we know how far the distance is for a give ring"
"0","        thisRing$distance <- distances[distancesCounter]"
"0","      }"
"0","      "
"0","      "
"0","      #otherwise, if this is the second or more ring (and a negative buffer)"
"0","      else if(distances[distancesCounter] < 0 & distancesCounter > 2) "
"0","      {"
"0","        #buffer by a specific distance"
"0","        buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])"
"0","        #create the next smallest buffer"
"0","        buffer2 <- st_buffer(inputPolygon, distances[distancesCounter-1])"
"0","        #This can then be used to difference out a buffer running from 660 to 1320"
"0","        #This works because differencing 1320ft by 660ft = a buffer between 660 & 1320."
"0","        #bc the area after 660ft in buffer2 = NA."
"0","        thisRing <- st_difference(buffer2,buffer1)"
"0","        #cast as apolygon"
"0","        thisRing <- st_cast(thisRing, ""POLYGON"")"
"0","        #get the last field"
"0","        thisRing <- as.data.frame(thisRing$geometry)"
"0","        #create the distance field"
"0","        thisRing$distance <- distances[distancesCounter]"
"0","      }"
"0","      "
"0","      #Otherwise, if its a positive buffer"
"0","      else "
"0","      {"
"0","        #Create a positive buffer"
"0","        buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])"
"0","        #create a positive buffer that is one distance smaller. So if its the first buffer"
"0","        #distance, buffer1_ will = 0. "
"0","        buffer1_ <- st_buffer(inputPolygon, distances[distancesCounter-1])"
"0","        #difference the two buffers"
"0","        thisRing <- st_difference(buffer1,buffer1_)"
"0","        #cast as a polygon"
"0","        thisRing <- st_cast(thisRing, ""POLYGON"")"
"0","        #geometry column as a data frame"
"0","        thisRing <- as.data.frame(thisRing[,ncol(thisRing)])"
"0","        #add teh distance"
"0","        thisRing$distance <- distances[distancesCounter]"
"0","      }  "
"0","      "
"0","      #rbind this ring to the rest of the rings"
"0","      allRings <- rbind(allRings, thisRing)"
"0","      #iterate the distance counter"
"0","      distancesCounter <- distancesCounter + 1"
"0","      #iterate the number of rings counter"
"0","      numberOfRingsCounter <- numberOfRingsCounter + 1"
"0","    }"
"0","    "
"0","    #convert the allRings data frame to an sf data frame"
"0","    allRings <- st_as_sf(allRings)"
"0","  }"
"0",""
"0","## Styling"
"0",""
"0","mapTheme <- function(base_size = 12) {"
"0","  theme("
"0","    text = element_text( color = ""black""),"
"0","    plot.title = element_text(size = 14,colour = ""black""),"
"0","    plot.subtitle=element_text(face=""italic""),"
"0","    plot.caption=element_text(hjust=0),"
"0","    axis.ticks = element_blank(),"
"0","    panel.background = element_blank(),axis.title = element_blank(),"
"0","    axis.text = element_blank(),"
"0","    axis.title.x = element_blank(),"
"0","    axis.title.y = element_blank(),"
"0","    panel.grid.minor = element_blank(),"
"0","    panel.border = element_rect(colour = ""black"", fill=NA, size=2),"
"0","    strip.text.x = element_text(size = 12))"
"0","}"
"0",""
"0","plotTheme <- function(base_size = 12) {"
"0","  theme("
"0","    text = element_text( color = ""black""),"
"0","    plot.title = element_text(size = 14,colour = ""black""),"
"0","    plot.subtitle = element_text(face=""italic""),"
"0","    plot.caption = element_text(hjust=0),"
"0","    axis.ticks = element_blank(),"
"0","    panel.background = element_blank(),"
"0","    panel.grid.major = element_line(""grey80"", size = 0.1),"
"0","    panel.grid.minor = element_blank(),"
"0","    panel.border = element_rect(colour = ""black"", fill=NA, size=2),"
"0","    strip.background = element_rect(fill = ""grey80"", color = ""white""),"
"0","    strip.text = element_text(size=12),"
"0","    axis.title = element_text(size=12),"
"0","    axis.text = element_text(size=10),"
"0","    plot.background = element_blank(),"
"0","    legend.background = element_blank(),"
"0","    legend.title = element_text(colour = ""black"", face = ""italic""),"
"0","    legend.text = element_text(colour = ""black"", face = ""italic""),"
"0","    strip.text.x = element_text(size = 12)"
"0","  )"
"0","} "
"0",""
"0","#Quantile Styling"
"0",""
"0","qBr <- function(df, variable, rnd) {"
"0"," if (missing(rnd)) {"
"0","     as.character(quantile(round(df[[variable]],0),"
"0","     c(.01,.2,.4,.6,.8), na.rm=T))"
"0","} else if (rnd == FALSE | rnd == F) {"
"0","  as.character(formatC(quantile(df[[variable]],"
"0","         c(.01,.2,.4,.6,.8), na.rm=T), digits = 3))"
"0","  }"
"0","}"
"0",""
"0","q5 <- function(variable) {as.factor(ntile(variable, 5))}"
"0",""
"0","#Color Palette used "
"0",""
"0","palette5 <- c(""#feebe2"",""#fbb4b9"",""#f768a1"",""#c51b8a"",""#7a0177"")"
"0",""
"0",""
"0","#ACS Data Used"
"0",""
"0","# Selected Variables for 2000 Dec and 2019 ACS: Tenure (Total owner occupied, renter Occupied), Median HH Income, Median Rent, Total Population, Total Housing Units, Total HH Below100p Poverty, and Number of Black Residents"
"0",""
"0","#2000 Decennial Census Data Pull "
"0",""
"0","dcTracts00 <-  "
"0","  get_decennial(geography = ""tract"", variables = c(""P053001"",""H056001"",""P001001"","
"0","                                             ""P092001"",""H007001"",""H007002"",""H007003"","
"0","                                             ""P006003""), "
"0","                year=2000, state=11, county=001, geometry=T) %>% "
"0","  st_transform('ESRI:102685')"
"2","Getting data from the 2000 decennial Census
"
"2","Downloading feature geometry from the Census website.  To cache shapefiles for use in future sessions, set `options(tigris_use_cache = TRUE)`.
"
"2","Variables not found in Summary File 1. Trying Summary File 3...
"
"1","  |                                                                                      "
"1","  |                                                                                |   0%"
"1","  |                                                                                      "
"1","  |=================================================                               |  62%"
"1","  |                                                                                      "
"1","  |================================================================================| 100%"
"1","
"
"0","#2019 ACS Data Pull "
"0",""
"0","dcTracts19 <-  "
"0","  get_acs(geography = ""tract"", variables = c(""B19013_001E"",  ""B25058_001E"",""B01003_001E"",""B25001_001E"",""B06012_002E"", ""B25026_002E"",""B25026_009E"", ""B02001_003E""), "
"0","                year=2019, state=11, county=001, geometry=T) %>% "
"0","  st_transform('ESRI:102685')"
"2","Getting data from the 2015-2019 5-year ACS
"
"2","Downloading feature geometry from the Census website.  To cache shapefiles for use in future sessions, set `options(tigris_use_cache = TRUE)`.
"
"1","  |                                                                                      "
"1","  |                                                                                |   0%"
"1","  |                                                                                      "
"1","  |=================================                                               |  41%"
"1","  |                                                                                      "
"1","  |================================================================================| 100%"
"1","
"
"0","#This policy brief is better suited to analyze the data in question when it has been spread into the Wide form"
"0",""
"0","#Conversion of 2000 Dec Census Data to Wide Form "
"0",""
"0","dcTracts00 <- "
"0","  dcTracts00 %>%"
"0","  dplyr::select( -NAME) %>%"
"0","  spread(variable, value) %>%"
"0","  dplyr::select(-geometry) %>%"
"0","  rename(MedHHInc = P053001, "
"0","         MedRent = H056001,"
"0","         TotalPop = P001001, TotalHHbPov = P092001, "
"0","         NumberBlk = P006003, "
"0","         TotalOHU = H007001,"
"0","         TotalOO = H007002, TotalRO = H007003)"
"0",""
"0","#Conversion of 2019 ACS Census Data to Wide Form "
"0",""
"0","dcTracts19 <- "
"0","  dcTracts19 %>%"
"0","  dplyr::select( -NAME, -moe) %>%"
"0","  spread(variable, estimate) %>%"
"0","  dplyr::select(-geometry) %>%"
"0","  rename(MedHHInc = B19013_001, "
"0","         MedRent = B25058_001,"
"0","         TotalPop = B01003_001, TotalHHbPov = B06012_002, "
"0","         NumberBlk = B02001_003, "
"0","         TotalOHU = B25001_001,"
"0","         TotalOO = B25026_002, TotalRO = B25026_009)"
"0",""
"0","#Creating New variables"
"0",""
"0","#2000 Census "
"0",""
"0","dcTracts00 <- "
"0","  dcTracts00 %>%"
"0","  mutate(pctBlk = ifelse(TotalPop > 0, NumberBlk / TotalPop, 0),"
"0","         pctRenter = ifelse(TotalOHU > 0, TotalRO / TotalOHU, 0), pctOwner = ifelse(TotalOHU > 0, (TotalOO / TotalOHU), 0),"
"0","         pctPoverty = ifelse(TotalPop > 0, TotalHHbPov / TotalPop, 0),"
"0","         year = ""2000"") %>%"
"0","  dplyr::select(-NumberBlk,-TotalHHbPov)"
"0",""
"0","#2019 ACS "
"0",""
"0","dcTracts19 <- "
"0","  dcTracts19 %>%"
"0","  mutate(pctBlk = ifelse(TotalPop > 0, NumberBlk / TotalPop, 0),"
"0","         pctRenter = ifelse(TotalOHU > 0, TotalRO / TotalOHU, 0), pctOwner = ifelse(TotalOHU > 0, (TotalOO / TotalOHU), 0),"
"0","         pctPoverty = ifelse(TotalPop > 0, TotalHHbPov / TotalPop, 0),"
"0","         year = ""2019"") %>%"
"0","  dplyr::select(-NumberBlk,-TotalHHbPov)"
"0",""
"0","#Combining 2000 and 2019 Census Data"
"0",""
"0","allTracts <- rbind(dcTracts00,dcTracts19)"
"0",""
