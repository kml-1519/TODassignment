"0","knitr::opts_chunk$set("
"0","    message = FALSE,"
"0","    warning = FALSE,"
"0","    include = FALSE"
"0",")"
"0","options(scipen=999)"
"0","options(tigris_class = ""sf"")"
"0",""
"0",""
"0","library(tidyverse)"
"2","Registered S3 methods overwritten by 'dbplyr':
  method         from
  print.tbl_lazy     
  print.tbl_sql      
"
"2","[30m-- [1mAttaching packages[22m ----------------------------------- tidyverse 1.3.1 --[39m
"
"2","[30m[32mv[30m [34mggplot2[30m 3.3.5     [32mv[30m [34mpurrr  [30m 0.3.4
[32mv[30m [34mtibble [30m 3.1.4     [32mv[30m [34mdplyr  [30m 1.0.7
[32mv[30m [34mtidyr  [30m 1.1.3     [32mv[30m [34mstringr[30m 1.4.0
[32mv[30m [34mreadr  [30m 2.0.1     [32mv[30m [34mforcats[30m 0.5.1[39m
"
"2","[30m-- [1mConflicts[22m -------------------------------------- tidyverse_conflicts() --
[31mx[30m [34mdplyr[30m::[32mfilter()[30m masks [34mstats[30m::filter()
[31mx[30m [34mdplyr[30m::[32mlag()[30m    masks [34mstats[30m::lag()[39m
"
"0","library(tidycensus)"
"0","library(sf)"
"2","Linking to GEOS 3.9.0, GDAL 3.2.1, PROJ 7.2.1
"
"0","library(tmap)"
"2","Registered S3 methods overwritten by 'htmltools':
  method               from         
  print.html           tools:rstudio
  print.shiny.tag      tools:rstudio
  print.shiny.tag.list tools:rstudio
"
"2","Registered S3 method overwritten by 'htmlwidgets':
  method           from         
  print.htmlwidget tools:rstudio
"
"0","library(kableExtra)"
"2","
Attaching package: â€˜kableExtraâ€™

"
"2","The following object is masked from â€˜package:dplyrâ€™:

    group_rows

"
"0","census_api_key(""1d63e5e6e661f6fd556f9671502bf3879e3a9fd3"", overwrite = TRUE)"
"2","To install your API key for use in future sessions, run this function with `install = TRUE`.
"
"0","#multiring buffer function"
"0","  multipleRingBuffer <- function(inputPolygon, maxDistance, interval) "
"0","  {"
"0","    #create a list of distances that we'll iterate through to create each ring"
"0","    distances <- seq(0, maxDistance, interval)"
"0","    #we'll start with the second value in that list - the first is '0'"
"0","    distancesCounter <- 2"
"0","    #total number of rings we're going to create"
"0","    numberOfRings <- floor(maxDistance / interval)"
"0","    #a counter of number of rings"
"0","    numberOfRingsCounter <- 1"
"0","    #initialize an otuput data frame (that is not an sf)"
"0","    allRings <- data.frame()"
"0","    "
"0","    #while number of rings  counteris less than the specified nubmer of rings"
"0","    while (numberOfRingsCounter <= numberOfRings) "
"0","    {"
"0","      #if we're interested in a negative buffer and this is the first buffer"
"0","      #(ie. not distance = '0' in the distances list)"
"0","      if(distances[distancesCounter] < 0 & distancesCounter == 2)"
"0","      {"
"0","        #buffer the input by the first distance"
"0","        buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])"
"0","        #different that buffer from the input polygon to get the first ring"
"0","        buffer1_ <- st_difference(inputPolygon, buffer1)"
"0","        #cast this sf as a polygon geometry type"
"0","        thisRing <- st_cast(buffer1_, ""POLYGON"")"
"0","        #take the last column which is 'geometry'"
"0","        thisRing <- as.data.frame(thisRing[,ncol(thisRing)])"
"0","        #add a new field, 'distance' so we know how far the distance is for a give ring"
"0","        thisRing$distance <- distances[distancesCounter]"
"0","      }"
"0","      "
"0","      "
"0","      #otherwise, if this is the second or more ring (and a negative buffer)"
"0","      else if(distances[distancesCounter] < 0 & distancesCounter > 2) "
"0","      {"
"0","        #buffer by a specific distance"
"0","        buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])"
"0","        #create the next smallest buffer"
"0","        buffer2 <- st_buffer(inputPolygon, distances[distancesCounter-1])"
"0","        #This can then be used to difference out a buffer running from 660 to 1320"
"0","        #This works because differencing 1320ft by 660ft = a buffer between 660 & 1320."
"0","        #bc the area after 660ft in buffer2 = NA."
"0","        thisRing <- st_difference(buffer2,buffer1)"
"0","        #cast as apolygon"
"0","        thisRing <- st_cast(thisRing, ""POLYGON"")"
"0","        #get the last field"
"0","        thisRing <- as.data.frame(thisRing$geometry)"
"0","        #create the distance field"
"0","        thisRing$distance <- distances[distancesCounter]"
"0","      }"
"0","      "
"0","      #Otherwise, if its a positive buffer"
"0","      else "
"0","      {"
"0","        #Create a positive buffer"
"0","        buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])"
"0","        #create a positive buffer that is one distance smaller. So if its the first buffer"
"0","        #distance, buffer1_ will = 0. "
"0","        buffer1_ <- st_buffer(inputPolygon, distances[distancesCounter-1])"
"0","        #difference the two buffers"
"0","        thisRing <- st_difference(buffer1,buffer1_)"
"0","        #cast as a polygon"
"0","        thisRing <- st_cast(thisRing, ""POLYGON"")"
"0","        #geometry column as a data frame"
"0","        thisRing <- as.data.frame(thisRing[,ncol(thisRing)])"
"0","        #add teh distance"
"0","        thisRing$distance <- distances[distancesCounter]"
"0","      }  "
"0","      "
"0","      #rbind this ring to the rest of the rings"
"0","      allRings <- rbind(allRings, thisRing)"
"0","      #iterate the distance counter"
"0","      distancesCounter <- distancesCounter + 1"
"0","      #iterate the number of rings counter"
"0","      numberOfRingsCounter <- numberOfRingsCounter + 1"
"0","    }"
"0","    "
"0","    #convert the allRings data frame to an sf data frame"
"0","    allRings <- st_as_sf(allRings)"
"0","  }"
