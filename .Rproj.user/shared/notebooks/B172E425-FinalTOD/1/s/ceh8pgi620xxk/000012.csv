"0","#Geom Line Plot, Mean Rent as a Function of Distance to Metro Stations "
"0",""
"0","#Creating a multi-ring buffer"
"0",""
"0","multipleRingBuffer <- function(inputPolygon, maxDistance, interval) "
"0","{"
"0","  #create a list of distances that we'll iterate through to create each ring"
"0","  distances <- seq(0, maxDistance, interval)"
"0","  #we'll start with the second value in that list - the first is '0'"
"0","  distancesCounter <- 2"
"0","  #total number of rings we're going to create"
"0","  numberOfRings <- floor(maxDistance / interval)"
"0","  #a counter of number of rings"
"0","  numberOfRingsCounter <- 1"
"0","  #initialize an otuput data frame (that is not an sf)"
"0","  allRings <- data.frame()"
"0","  "
"0","  #while number of rings  counteris less than the specified nubmer of rings"
"0","  while (numberOfRingsCounter <= numberOfRings) "
"0","  {"
"0","    #if we're interested in a negative buffer and this is the first buffer"
"0","    #(ie. not distance = '0' in the distances list)"
"0","    if(distances[distancesCounter] < 0 & distancesCounter == 2)"
"0","    {"
"0","      #buffer the input by the first distance"
"0","      buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])"
"0","      #different that buffer from the input polygon to get the first ring"
"0","      buffer1_ <- st_difference(inputPolygon, buffer1)"
"0","      #cast this sf as a polygon geometry type"
"0","      thisRing <- st_cast(buffer1_, ""POLYGON"")"
"0","      #take the last column which is 'geometry'"
"0","      thisRing <- as.data.frame(thisRing[,ncol(thisRing)])"
"0","      #add a new field, 'distance' so we know how far the distance is for a give ring"
"0","      thisRing$distance <- distances[distancesCounter]"
"0","    }"
"0","    "
"0","    "
"0","    #otherwise, if this is the second or more ring (and a negative buffer)"
"0","    else if(distances[distancesCounter] < 0 & distancesCounter > 2) "
"0","    {"
"0","      #buffer by a specific distance"
"0","      buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])"
"0","      #create the next smallest buffer"
"0","      buffer2 <- st_buffer(inputPolygon, distances[distancesCounter-1])"
"0","      #This can then be used to difference out a buffer running from 660 to 1320"
"0","      #This works because differencing 1320ft by 660ft = a buffer between 660 & 1320."
"0","      #bc the area after 660ft in buffer2 = NA."
"0","      thisRing <- st_difference(buffer2,buffer1)"
"0","      #cast as apolygon"
"0","      thisRing <- st_cast(thisRing, ""POLYGON"")"
"0","      #get the last field"
"0","      thisRing <- as.data.frame(thisRing$geometry)"
"0","      #create the distance field"
"0","      thisRing$distance <- distances[distancesCounter]"
"0","    }"
"0","    "
"0","    #Otherwise, if its a positive buffer"
"0","    else "
"0","    {"
"0","      #Create a positive buffer"
"0","      buffer1 <- st_buffer(inputPolygon, distances[distancesCounter])"
"0","      #create a positive buffer that is one distance smaller. So if its the first buffer"
"0","      #distance, buffer1_ will = 0. "
"0","      buffer1_ <- st_buffer(inputPolygon, distances[distancesCounter-1])"
"0","      #difference the two buffers"
"0","      thisRing <- st_difference(buffer1,buffer1_)"
"0","      #cast as a polygon"
"0","      thisRing <- st_cast(thisRing, ""POLYGON"")"
"0","      #geometry column as a data frame"
"0","      thisRing <- as.data.frame(thisRing[,ncol(thisRing)])"
"0","      #add teh distance"
"0","      thisRing$distance <- distances[distancesCounter]"
"0","    }  "
"0","    "
"0","    #rbind this ring to the rest of the rings"
"0","    allRings <- rbind(allRings, thisRing)"
"0","    #iterate the distance counter"
"0","    distancesCounter <- distancesCounter + 1"
"0","    #iterate the number of rings counter"
"0","    numberOfRingsCounter <- numberOfRingsCounter + 1"
"0","  }"
"0","  "
"0","  #convert the allRings data frame to an sf data frame"
"0","  allRings <- st_as_sf(allRings)"
"0","}"
"0",""
"0","metroBuffers <- rbind("
"0","  st_buffer(metro_stops,2640) %>% "
"0","    mutate(Legend = ""Buffer"") %>% "
"0","    dplyr::select(Legend),"
"0","  st_union(st_buffer(metro_stops,2640)) %>% "
"0","    st_sf() %>% "
"0","    mutate(Legend = ""Unionized Buffer""),"
"0","  st_union(st_buffer(metro_stops,1)) %>% "
"0","    st_sf() %>% "
"0","    mutate(Legend = ""1-foot Buffer"")"
"0",")"
"0",""
"0","buffer <- filter(metroBuffers, Legend==""Unionized Buffer"")"
"0","onefoot <- filter(metroBuffers, Legend==""1-foot Buffer"")"
"0",""
"0","allTracts.rings <-"
"0","  st_join(st_centroid(dplyr::select(allTracts, GEOID, year)), "
"0","          multipleRingBuffer(onefoot, 26400, 2640)) %>%"
"0","  st_drop_geometry() %>%"
"0","  left_join(dplyr::select(allTracts, GEOID, MedRent, year), "
"0","            by=c(""GEOID""=""GEOID"", ""year""=""year"")) %>%"
"0","  st_sf() %>%"
"0","  mutate(distance = distance / 5280) #convert to miles"
"2","Warning in st_centroid.sf(dplyr::select(allTracts, GEOID, year)) :"
"2","
 "
"2"," st_centroid assumes attributes are constant over geometries of x
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"2","Warning in st_cast.sf(thisRing, ""POLYGON"") :"
"2","
 "
"2"," repeating attributes for all sub-geometries for which they may not be constant
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"2","Warning in st_cast.sf(thisRing, ""POLYGON"") :"
"2","
 "
"2"," repeating attributes for all sub-geometries for which they may not be constant
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"2","Warning:"
"2"," attribute variables are assumed to be spatially constant throughout all geometries
"
"0","          "
